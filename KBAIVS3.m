KBAIVS3	; GPL - NLM VALUESET IMPORT ROUTINES FILEMAN VERSION ; 11/1/13 6:03PM
	;;0.1;C0Q;NOPATCH;NORELEASEDATE;Build 13
	;COPYRIGHT 2013 GEORGE LILLY.  LICENSED APACHE 2
	;
	Q
	;
	; THIS VERSION OF THE NLM VALUESET IMPORTER IMPORTS THE VALUESETS TO THREE
	;   FILEMAN FILES:
	;
	; ^DIC(176.801,0)="C0Q VALUE SET CODES^176.801"
	; ^DIC(176.802,0)="C0Q NLM QUALITY MEASURE GROUPS^176.802"
	; ^DIC(176.803,0)="C0Q CODE SYSTEMS^176.803"
	;
	;
	Q
	;
C0QVSFN()	Q 176.801  ; FILE NUMBER OF C0Q VALUE SET CODES FILE
C0QVSCFN()	Q 176.8011  ; SUBFILE NUMBER OF VALUE SET CODES MULTIPLE
C0QVSGFN()	Q 176.8012  ; SUBFILE NUMBER OF VALUE SET MEASURE GROUP MULTIPLE
	;
C0QGRFN()	Q 176.802  ; FILE NUMBER OF THE C0Q NLM MEASURE GROUP FILE
C0QGRCD()	Q 176.8024  ; SUBFILE NUMBER OF THE CODE SET SUBFILE
	;
C0QBKFN()	Q 176.888 ; MAPPING BACKUP FILE
C0QBKID()	Q 176.8881 ; MAPPING BACKUP IDENTIFIER SUBFILE
C0QBKFLD()	Q 176.88811 ; FIELD SUBFILE OF IDENTIFIER SUBFILE OF MAPPING BACKUP FILE
	;
	; FIELD IDENTIFIERS FOR ADDING TO THE MEASURE GROUP FILE
GRPFLDS	; format = identifier^field number
	;;CATEGORY^2.1
	;;CMS eMeasure ID^2.2
	;;Endorsed By^2.3
	;;GUID^.02
	;;Meaningful Use Measures^2.4
	;;Measure Developer^2.5
	;;Measure Steward^2.6
	;;Measure Type^2.7
	;;NQF Number^.03
	;;SHEETNAME^2.8
	;;eMeasure Copyright^2.9
	;;eMeasure Description^1.1
	;;eMeasure Identifier^3
	;;eMeasure Status^3.1
	;;eMeasure Title^.01
	;;eMeasure Version number^.04
	Q
	;
ADDGRPS	; ADDS GROUPS TO 176.802. 
	;
	N GN S GN=$NA(^KBAI("KBAIVS","ALLGROUPS"))
	N GUID S GUID=""
	F  S GUID=$O(@GN@(GUID)) Q:GUID=""  D  ;
	. K KBAIFDA
	. N SEQ,MAP,TAG,FIELD
	. F SEQ=1:1 S MAP=$P($T(GRPFLDS+SEQ),";;",2) Q:MAP=""  D  ;
	. . S TAG=$P(MAP,"^",1)
	. . S FIELD=$P(MAP,"^",2)
	. . S KBAIFDA($$C0QGRFN,"?+1,",FIELD)=$$CLEAN($G(@GN@(GUID,TAG)))
	. N KBAIEN
	. D UPDIE(.KBAIFDA,.KBAIEN)
	. ;
	. N KBAIMSG
	. N KBAIWPR S KBAIWPR(1,0)=$G(@GN@(GUID,"EMEASURE DESCRIPTION"))
	. D WP^DIE($$C0QGRFN,KBAIEN(1)_",",1,"K","KBAIWPR","KBAIMSG")
	. I $G(DIERR) BREAK
	Q
	;
TREE(WHERE,PREFIX)	; SHOW A TREE STARTING AT A NODE IN MXML. WHERE IS PASSED BY VALUE
	; 
	I $G(PREFIX)="" S PREFIX="|--" ; STARTING PREFIX
	;I '$D(C0XJOB) S C0XJOB=$J
	N NODE S NODE=$NA(^KBAI("KBAIVS","DOM",WHERE))
	N TXT S TXT=$$CLEAN($$ALLTXT(NODE))
	W !,PREFIX_@NODE_" "_TXT
	N ZI S ZI=""
	F  S ZI=$O(@NODE@("A",ZI)) Q:ZI=""  D  ;
	. W !,PREFIX_"  : "_ZI_"^"_$G(@NODE@("A",ZI))
	F  S ZI=$O(@NODE@("C",ZI)) Q:ZI=""  D  ;
	. D TREE(ZI,"|  "_PREFIX)
	Q
	;
SHOW(WHAT)	;
	;S C0XJOB=26295
	I '$D(C0XJOB) S C0XJOB=$J
	D TREE(WHAT)
	Q
	; 
TREE2(WHERE,PREFIX)	; SHOW A TREE STARTING AT A NODE IN MXML. WHERE IS PASSED BY VALUE
	; TREE2 HANDLES CONCEPTLISTS AS TABLES
	I $G(PREFIX)="" S PREFIX="|--" ; STARTING PREFIX
	I '$D(C0XJOB) S C0XJOB=$J
	N NODE S NODE=$NA(^KBAI("KBAIVS","DOM",WHERE))
	;N TXT S TXT=$$CLEAN($$ALLTXT(NODE))
	N TXT D ALLTXT2(.TXT,NODE)
	;W !,PREFIX_@NODE_" "_TXT
	N ZK S ZK=""
	F  S ZK=$O(TXT(ZK)) Q:ZK=""  D  ;
	. I ZK=1 D OUT(PREFIX_@NODE_" "_TXT(ZK))  Q  ;
	. D OUT(PREFIX_TXT(ZK))
	I @NODE["ns0:ConceptList" D  Q  ;
	. D CLIST(WHERE,PREFIX)
	N ZI S ZI=""
	F  S ZI=$O(@NODE@("A",ZI)) Q:ZI=""  D  ;
	. ;W !,PREFIX_"  : "_ZI_"^"_$G(@NODE@("A",ZI))
	. D OUT(PREFIX_"  : "_ZI_"^"_$G(@NODE@("A",ZI)))
	N GRPSTART S GRPSTART=0
	F  S ZI=$O(@NODE@("C",ZI)) Q:ZI=""  D  ;
	. I @NODE@("C",ZI)="ns0:RevisionDate" D NEWGRP
	. I @NODE@("C",ZI)="ns0:Group" D GROUP(ZI)  Q  ;
	. D TREE2(ZI,"|  "_PREFIX)
	D:GRPSTART GRPOUT2
	Q
	;
NEWGRP	; KILL THE GROUP ARRAY FOR A NEW GROUP
	;W !,"NEW GROUP"
	K ^KBAI("KBAIVS","GROUP")
	Q
	;
GROUP(WHERE)	; ADD A GROUP NODE TO THE GROUP ARRAY
	S GRPSTART=1
	N GN S GN=$NA(^KBAI("KBAIVS","GROUP"))
	N NODE S NODE=$NA(^KBAI("KBAIVS","DOM"))
	N GNUM S GNUM=$G(@NODE@(WHERE,"A","ID"))
	I GNUM="" D  Q  ;
	. W !,"ERROR FINDING GROUP NUMBER ",WHERE
	N VAR S VAR=@NODE@(WHERE,"A","displayName")
	N VALREF S VALREF=$O(@NODE@(WHERE,"C",""))
	I VALREF="" D  Q  ;
	. W !,"ERROR FINDING VALUE REFERENCE ",WHERE
	N VAL S VAL=@NODE@(VALREF,"T",1)
	S @GN@(GNUM,VAR)=VAL
	Q
	;
GRPOUT	; OUTPUT THE GROUP ARRAY
	N GN S GN=$NA(^KBAI("KBAIVS","GROUP"))
	N GRP S GRP=""
	F  S GRP=$O(@GN@(GRP)) Q:GRP=""  D  ;
	. D OUT("--------------------------------------------------------------")
	. N ATTR S ATTR=""
	. F  S ATTR=$O(@GN@(GRP,ATTR)) Q:ATTR=""  D  ;
	. . D OUT(ATTR_": "_@GN@(GRP,ATTR))
	Q
	;
GRPOUT2	; MERGE THE GROUP ARRAY WITH ALL GROUPS
	N GN S GN=$NA(^KBAI("KBAIVS","GROUP"))
	N GNALL S GNALL=$NA(^KBAI("KBAIVS","ALLGROUPS"))
	N GRP S GRP=""
	F  S GRP=$O(@GN@(GRP)) Q:GRP=""  D  ;
	. N GUID S GUID=$G(@GN@(GRP,"GUID"))
	. I GUID="" D  Q  ;
	. . W !,"NO GUID FOR ",$O(@GN@(GRP,""))
	. M @GNALL@(GUID)=@GN@(GRP)
	. N MIEN S MIEN=$O(^C0QVS(176.802,"GUID",GUID,""))
	. I MIEN="" D  Q  ;
	. . W !,"MEASURE FILE NOT BUILT YET... RUN ADDGRPS THEN RERUN IMPORT"
	. K KBAIFDA
	. I $G(KBAIREC)="" D  Q  ;
	. . W:$G(DEBUG) !,"KBAIREC NOT DEFINED, SKIPPING ",GUID
	. S KBAIFDA($$C0QVSGFN,"?+1,"_KBAIREC_",",.01)=MIEN
	. N KBAIIEN
	. D UPDIE(.KBAIFDA,.KBAIIEN)
	. K KBAIFDA,KBAIIEN
	. S KBAIFDA($$C0QGRCD,"?+1,"_MIEN_",",.01)=KBAIREC
	. D UPDIE(.KBAIFDA,.KBAIIEN)
	Q
	;
LDCODES	; load codes into the value set code multiple
	N CONT
	D CONTENTS2("CONT")
	K ^KBAI("LEXRPT") ; clear out reporting area
	N ZI S ZI=""
	F  S ZI=$O(CONT("ID",ZI)) Q:ZI=""  D  ; 
	. N ZJ S ZJ=$O(CONT("ID",ZI,""))
	. D LDONE(ZJ,ZI)
	Q
	;
LDONE(ZNODE,ZID)	; load codes for one code list
	N GN S GN=$NA(^KBAI("KBAIVS","DOM"))
	N ZC S ZC=$O(@GN@(ZNODE,"C",""))
	I @GN@(ZNODE,"C",ZC)'="ns0:ConceptList" D  B  ;
	. W !,"ERROR, NOT A CONCEPT LIST ",ZC
	W !,ZC
	D CLIST2(ZC,ZID)
	Q
	;
CLIST(WHERE,PREFIX,NOHEAD)	
	N ND S ND=$NA(^KBAI("KBAIVS","DOM"))
	;I '$D(NOHEAD) S NOHEAD=0
	;I 'NOHEAD D  ;
	D OUT($J("CODE",20)_$J("SYSTEM",10)_$J("DESCRIPTION",20))
	N ZZI S ZZI=""
	F  S ZZI=$O(@ND@(WHERE,"C",ZZI)) Q:ZZI=""  D  ;
	. N CODE,SYSTEM,DESC,VER
	. S CODE=$G(@ND@(ZZI,"A","code"))
	. S SYSTEM=$G(@ND@(ZZI,"A","codeSystemName"))
	. S VER=$G(@ND@(ZZI,"A","codeSystemVersion"))
	. S DESC=$G(@ND@(ZZI,"A","displayName"))
	. D OUT($J(CODE,20)_$J(SYSTEM,10)_$J(VER,6)_"  "_DESC)
	;W @ND,":",@ND@("T",1)  
	Q
	;
CLIST2(WHERE,ZID)	; add a code list to the code list multiple at VS ZID
	N ND S ND=$NA(^KBAI("KBAIVS","DOM"))
	N VS S VS=$O(^C0QVS(176.801,"ID",ZID,""))
	I VS="" D  Q  ;
	. W !,"ERROR ID NOT FOUND IN FILE ",ZID
	K KBAIFDA
	N ZZI S ZZI=""
	N ZN S ZN=0
	F  S ZZI=$O(@ND@(WHERE,"C",ZZI)) Q:ZZI=""  D  ;
	. N CODE,SYSTEM,DESC,VER
	. S CODE=$G(@ND@(ZZI,"A","code"))
	. S SYSID=$G(@ND@(ZZI,"A","codeSystem"))
	. S SYSNAME=$G(@ND@(ZZI,"A","codeSystemName"))
	. S VER=$G(@ND@(ZZI,"A","codeSystemVersion"))
	. S DESC=$G(@ND@(ZZI,"A","displayName"))
	. S DESC=$TR(DESC,"^"," ")
	. S ZN=ZN+1
	. S KBAIFDA($$C0QVSCFN(),"?+"_ZN_","_VS_",",.01)=CODE
	. S KBAIFDA($$C0QVSCFN(),"?+"_ZN_","_VS_",",.02)=DESC
	. S KBAIFDA($$C0QVSCFN(),"?+"_ZN_","_VS_",",.04)=SYSNAME
	. S KBAIFDA($$C0QVSCFN(),"?+"_ZN_","_VS_",",.05)=SYSID
	. S KBAIFDA($$C0QVSCFN(),"?+"_ZN_","_VS_",",.06)=VER
	. ;D OUT($J(CODE,20)_$J(SYSTEM,10)_$J(VER,6)_"  "_DESC)
	. ; check to see if the SNOMED code is in the Lexicon
	. ;
	. I SYSNAME["SNOMED" D  ; 
	. . N LEXS,LEXRPT
	. . S LEXRPT=$NA(^KBAI("LEXRPT"))
	. . D EN^LEXCODE(CODE)
	. . I $D(LEXS("SCT",1)) D  ; found in the lexicon
	. . . I '$D(@LEXRPT@("FOUND",CODE)) S @LEXRPT@("COUNT","FOUND","NONDUP")=$G(@LEXRPT@("COUNT","FOUND","NONDUP"))+1
	. . . S @LEXRPT@("COUNT","FOUND")=$G(@LEXRPT@("COUNT","FOUND"))+1
	. . . S @LEXRPT@("FOUND",CODE)=DESC
	. . E  D  ; not found in the lexicon
	. . . I '$D(@LEXRPT@("NOTFOUND",CODE)) S @LEXRPT@("COUNT","NOTFOUND","NONDUP")=$G(@LEXRPT@("COUNT","NOTFOUND","NONDUP"))+1
	. . . S @LEXRPT@("COUNT","NOTFOUND")=$G(@LEXRPT@("COUNT","NOTFOUND"))+1
	. . . S @LEXRPT@("NOTFOUND",CODE)=DESC
	D UPDIE(.KBAIFDA)
	Q
	;
OUT(TXT)	; ADD LINE TO OUTPUT ARRAY
	Q  ; DO NOTHING
	;W !,TXT
	S C0XOUT=$NA(^KBAI("KBAIOUT",$J))
	N CNT
	S CNT=$O(@C0XOUT@(""),-1)
	I CNT="" S CNT=0
	S @C0XOUT@(CNT+1)=TXT
	Q
	;
ALLTXT2(RTN,NODE)	; HANDLE ARRAYS OF TEXT
	M RTN=@NODE@("T")
	N ZJ S ZJ=""
	F  S ZJ=$O(RTN(ZJ)) Q:ZJ=""  D  ;
	. S RTN(ZJ)=$$CLEAN(RTN(ZJ))
	. S RTN(ZJ)=$$LDBLNKS(RTN(ZJ))
	. I RTN(ZJ)="" K RTN(ZJ)
	. I (RTN(ZJ)=" ")&(ZJ>1) K RTN(ZJ)
	Q
	;
ALLTXT(WHERE)	; EXTRINSIC WHICH RETURNS ALL TEXT LINES FROM THE NODE .. CONCATINATED 
	; TOGETHER
	N ZTI S ZTI=""
	N ZTR S ZTR=""
	F  S ZTI=$O(@WHERE@("T",ZTI)) Q:ZTI=""  D  ;
	. S ZTR=ZTR_$G(@WHERE@("T",ZTI))
	Q ZTR
	;
CLEAN(STR)	; EXTRINSIC FUNCTION; RETURNS STRING - GPL BORROWED FROM THE CCR PACKAGE
	;; REMOVES ALL NON PRINTABLE CHARACTERS FROM A STRING.
	;; STR BY VALUE
	N TR,I
	F I=0:1:31,128:1:256 S TR=$G(TR)_$C(I)
	S TR=TR_$C(127)
	N ZR S ZR=$TR(STR,TR)
	S ZR=$$LDBLNKS(ZR) ; GET RID OF LEADING BLANKS
	QUIT ZR
	;
LDBLNKS(ST)	; EXTRINSIC WHICH REMOVES LEADING BLANKS FROM A STRING
	N POS F POS=1:1:$L(ST)  Q:$E(ST,POS)'=" "
	Q $E(ST,POS,$L(ST))
	;
VACCD	; SET C0XJOB TO THE VA CCD
	S C0XJOB=14921
	Q
	;
NLMVS	; SET C0XJOB TO THE NLM VALUES SET XML
	S C0XJOB=26295
	Q
	;
CONTENTS(ZRTN,IDS)	; PRODUCE AN AGENDA FOR THE DOCID 1 IN THE MXML DOM
	; GENERALLY, A FIRST LEVEL INDEX TO THE DOCUMENT
	; SET C0XJOB IF YOU WANT TO USE A DIFFERENT $J TO LOCATE THE DOM
	; ZRTN PASSED BY NAME
	; IDS=1 NAMES THEM BY NUMBER IDS=0 OR NULL NAMES THEM BY DISPLAYNAME
	N ZI S ZI=""
	N DOM S DOM=$NA(^KBAI("KBAIVS","DOM"))
	F  S ZI=$O(@DOM@(1,"C",ZI)) Q:ZI=""  D  ;
	. N ZN ;
	. D:$G(IDS)  ;
	. . S ZN=$TR($G(@DOM@(ZI,"A","ID")),".","-")_".txt"
	. . S @ZRTN@(ZN,ZI)=""
	. D:'$G(IDS)  ;
	. . S ZN=$TR($G(@DOM@(ZI,"A","displayName"))," ","_")_".txt"
	. . S ZN=$TR(ZN,"()","") ; GET RID OF PARENS FOR VALID FILENAME
	. . S ZN=$TR(ZN,"/","-") ; GET RID OF SLASH FOR VALID FILENAME
	. . S @ZRTN@(ZN,ZI)=""
	Q
	;
CONTENTS2(ZRTN)	; PRODUCE AN AGENDA FOR THE DOCID 1 IN THE MXML DOM
	; GENERALLY, A FIRST LEVEL INDEX TO THE DOCUMENT
	; SET C0XJOB IF YOU WANT TO USE A DIFFERENT $J TO LOCATE THE DOM
	; ZRTN PASSED BY NAME
	N ZI S ZI=""
	N DOM S DOM=$NA(^KBAI("KBAIVS","DOM"))
	F  S ZI=$O(@DOM@(1,"C",ZI)) Q:ZI=""  D  ;
	. N ZN,ZID,ZIDFILE,ZFILE ;
	. S ZID=$G(@DOM@(ZI,"A","ID"))
	. S @ZRTN@("ID",ZID,ZI)=""
	. S @ZRTN@(ZI,"ID")=ZID
	. S ZIDFILE=$TR($G(@DOM@(ZI,"A","ID")),".","-")_".txt"
	. S @ZRTN@("IDFILE",ZIDFILE,ZI)=""
	. S @ZRTN@(ZI,"IDFILE")=ZIDFILE
	. S ZN=$G(@DOM@(ZI,"A","displayName"))
	. S @ZRTN@("NAME",ZN,ZI)=""
	. S @ZRTN@(ZI,"NAME")=ZN
	. N SID S SID=$$SID^KBAISID(ZN,ZID)
	. S @ZRTN@(ZI,"SID")=SID
	. S @ZRTN@("SID",SID,ZI)=""
	. S ZFILE=$TR($G(@DOM@(ZI,"A","displayName"))," ","_")_"-"_SID_".txt"
	. S ZFILE=$TR(ZFILE,"()","") ; GET RID OF PARENS FOR VALID FILENAME
	. S ZFILE=$TR(ZFILE,"/","-") ; GET RID OF SLASH FOR VALID FILENAME
	. S @ZRTN@("FILE",ZFILE,ZI)=""
	. S @ZRTN@(ZI,"FILE")=ZFILE
	S ZI=""
	;F  S ZI=$O(@ZRTN@("ID",ZI)) Q:ZI=""  D  ;
	;. N ZIEN S ZIEN=$O(@ZRTN@("ID",ZI,""))
	;. N SID S SID=$$SID^KBAISID(@ZRTN@(ZIEN,"NAME"),ZI)
	;. S @ZRTN@(ZIEN,"SID")=SID
	;. S @ZRTN@("SID",SID,ZIEN)=""
	Q
	;
IMPORT	; IMPORTS VALUE SETS INTO FILEMAN FILES
	; 
	N G,ZI,ZNAME,WHERE,DIRNAME,GN,ZID
	S GN=$NA(^KBAI("KBAIOUT",$J))
	;W !,"PLEASE ENTER DIRECTORY NAME FOR VALUESET FILES BY NAME"
	;Q:'$$GETDIR(.DIRNAME,"/home/vista/VALUESETS/BY-NAME/")
	S ZI=""
	D CONTENTS2("G") ; NEW CONTENTS FORMAT INCLUDES BOTH NAME AND ID
	F  S ZI=$O(G("NAME",ZI)) Q:ZI=""  D  ;
	. N ZNUM S ZNUM=""
	. F  S ZNUM=$O(G("NAME",ZI,ZNUM)) Q:ZNUM=""  D  ;
	. . S ZID=G(ZNUM,"ID")
	. . S KBAIREC=$$LAYGO(ZI,ZID) ; ADD THE RECORD IF IT'S NOT ALREADY THERE
	. . ;K KBAIFDA
	. . ;S KBAIFDA($$C0QVSFN,"?+1,",.01)=ZI
	. . ;S KBAIFDA($$C0QVSFN,"?+1,",.02)=ZID
	. . ;N KBAIIEN
	. . ;D UPDIE(.KBAIFDA,.KBAIIEN) ; KBAIIEN IS IEN OF THE CURRENT VALUESET (SEE GROUPOUT2)
	. . ;S KBAIREC=$G(KBAIIEN)
	. . ;I KBAIREC="" D  ;
	. . ;. S KBAIREC=$O(^C0QVS(176.801,"ID",ZID,""))
	. . ;. I KBAIREC="" B  ;
	. . ;S WHERE=$O(G("NAME",ZI,""))
	. . S WHERE=ZNUM ; per Mark Taylor --- thanks Mark
	. . S KBAIROOT=WHERE ; NODE OF CURRENT VALUE SET 
	. . ;K @GN
	. . D TREE2(WHERE,"| ")
	. . ;N GN2 S GN2=$NA(@GN@(1)) ; NAME FOR GTF
	. . ;S OK=$$GTF^%ZISH(GN2,3,DIRNAME,G(ZNUM,"FILE"))
	Q
	;
LAYGO(ZNAME,ZOID)	; EXTRINSIC THAT RETURNS THE IEN, ADDS THE RECORD IF IT'S NEW
	;
	N GN S GN=$NA(^C0QVS(176.801,"ID"))
	N ZIEN
	S ZIEN=$O(@GN@(ZOID,""))
	I ZIEN'="" Q ZIEN
	K KBAIFDA
	S KBAIFDA($$C0QVSFN,"+1,",.01)=ZNAME
	S KBAIFDA($$C0QVSFN,"+1,",.02)=ZOID
	W !,"WILL ADD: ",ZNAME," ",ZOID
	D UPDIE(.KBAIFDA,.ZIEN) ; ZIEN IS IEN OF THE CURRENT VALUESET (SEE GROUPOUT2)
	Q ZIEN(1)  ; per Mark Taylor --- thanks Mark
	;
IMPSID	; IMPORT ALL THE SIDS
	;
	N G
	D CONTENTS2("G")
	N GN S GN=$NA(^C0QVS(176.801))
	K KBAIFDA
	N ZOID S ZOID=""
	F  S ZOID=$O(G("ID",ZOID)) Q:ZOID=""  D  ;
	. N ZIEN
	. S ZIEN=$O(@GN@("ID",ZOID,""))
	. N ZSID
	. N GREC S GREC=$O(G("ID",ZOID,""))
	. S ZSID=G(GREC,"SID")
	. S KBAIFDA($$C0QVSFN,ZIEN_",",.03)=ZSID
	N ZIEN
	;B
	D UPDIE(.KBAIFDA,.ZIEN)
	Q
	;
FILEIN	; IMPORT THE VALUESET XML FILE, PARSE WITH MXML, AND PUT THE DOM IN ^TMP
	;
	N FNAME,DIRNAME
	W !,"PLEASE ENTER THE DIRECTORY AND FILE NAME FOR THE NLM VALUESET XML FILE"
	Q:'$$GETDIR(.DIRNAME,"/home/vista/nlm-vs") ; PROMPT THE USER FOR THE DIRECTORY
	Q:'$$GETFN(.FNAME,"ep_eh_unique_vs_20140701.xml") ; PROMPT USER FOR FILENAME
	N GN S GN=$NA(^KBAI("KBAIVS")) ; ROOT TO STORE XML AND DOM
	K @GN ; CLEAR THE AREA
	N GN1 S GN1=$NA(@GN@("XML",1)) ; PLACE TO PUT THE XML FILE
	W !,"READING IN FILE ",FNAME," FROM DIRECTORY ",DIRNAME
	Q:$$FTG^%ZISH(DIRNAME,FNAME,GN1,3)=""
	N KBAIDID
	W !,"PARSING FILE ",FNAME
	S KBAIDID=$$EN^MXMLDOM($NA(@GN@("XML")),"W")
	I KBAIDID=0 D  Q  ;
	. ZWRITE ^TMP("MXMLERR",$J,*)
	W !,"MERGING MXMLDOM TO TMP"
	M @GN@("DOM")=^TMP("MXMLDOM",$J,KBAIDID)
	K ^TMP("MXMLDOM",$J)
	Q
	;
VALIDATE ; check to make sure there are no codes in multiple valuesets
 N OK S OK=1
 N ZI S ZI=""
 N GL S GL=$NA(^C0QVS(176.801,"CODE"))
 F  S ZI=$O(@GL@(ZI)) Q:ZI=""  S %1=$O(@GL@(ZI,"")) I $O(@GL@(ZI,%1))'="" W !,"DISASTER HAS HAPPENED!!!! THIS CODE IS IN MORE THAN ONE VALUESET: ",ZI S OK=0
 W:OK "VALIDATED"
 Q
 ;
GETDIR(KBAIDIR,KBAIDEF)	; EXTRINSIC WHICH PROMPTS FOR DIRECTORY
	; RETURNS TRUE IF THE USER GAVE VALUES
	S DIR(0)="F^3:240"
	S DIR("A")="FILE DIRECTORY"
	I '$D(KBAIDEF) S KBAIDEF="/home/vista/nlm-vs"
	S DIR("B")=KBAIDEF
	D ^DIR
	I Y="^" Q 0 ;
	S KBAIDIR=Y
	Q 1
	;
GETFN(KBAIFN,KBAIDEF)	; EXTRINSIC WHICH PROMPTS FOR FILENAME
	; RETURNS TRUE IF THE USER GAVE VALUES
	S DIR(0)="F^3:240"
	S DIR("A")="FILE NAME"
	I '$D(KBAIDEF) S KBAIDEF="ep_eh_unique_vs_20140701.xml"
	S DIR("B")=KBAIDEF
	D ^DIR
	I Y="" Q 0 ;
	I Y="^" Q 0 ;
	S KBAIFN=Y
	Q 1
	;
UPDIE(ZFDA,ZIEN)	; INTERNAL ROUTINE TO CALL UPDATE^DIE AND CHECK FOR ERRORS
	; ZFDA IS PASSED BY REFERENCE
	; ZIEN IS PASSED BY REFERENCE
	D:$G(DEBUG)
	. ZWRITE ZFDA
	. B
	K ZERR
	D CLEAN^DILF
	D UPDATE^DIE("K","ZFDA","ZIEN","ZERR")
	I '$G(TRUST) I $D(ZERR) S ZZERR=ZZERR ; ZZERR DOESN'T EXIST,
	; INVOKE THE ERROR TRAP IF TASKED
	;. W "ERROR",!
	;. ZWR ZERR
	;. B
	K ZFDA
	Q
	;
BKMAPS	; THIRD TIME'S A CHARM ... BRUTE FORCE
	N GN S GN=$NA(^KBAI("VSBAK"))
	K @GN
	N GV S GV=$NA(^C0QVS(176.802))
	M @GN@("CQM")=@GV@("CQM")
	M @GN@("GUID")=@GV@("GUID")
	M @GN@("CAT")=@GV@("CAT")
	M @GN@("ID")=@GV@("ID")
	N ZI S ZI=""
	F  S ZI=$O(@GN@(ZI)) Q:ZI=""  D  ;
	. I ZI="ROOT" Q  ;
	. N VAL S VAL=""
	. F  S VAL=$O(@GN@(ZI,VAL)) Q:VAL=""  D  ;
	. . N REC S REC=""
	. . F  S REC=$O(@GN@(ZI,VAL,REC)) Q:REC=""  D  ;
	. . . S @GN@("ROOT",REC,ZI,VAL)=""
	Q
	;
RESTORE	; RESTORES MAPPING FIELDS TO 176.802 FROM BACKUP
	; THIS IS USED AFTER LOADING A NEW SVS XML FILE
	N ZI S ZI=""
	S GN=$NA(^KBAI("VSBAK","ROOT")) ; LOCATION OF THE BACKUP (SEE BKMAPS ABOVE)
	F  S ZI=$O(@GN@(ZI)) Q:ZI=""  D  ;
	. N ZID S ZID=$O(@GN@(ZI,"GUID","")) ; MEASURE GUID
	. Q:ZID=""
	. W !,ZID
	. N ZIEN S ZIEN=$O(^C0QVS(176.802,"GUID",ZID,"")) ; RECORD TO UPDATE
	. Q:ZIEN=""
	. W " ",ZIEN
	. K KBAIFDA
	. S KBAIFDA($$C0QGRFN(),ZIEN_",",5)=$O(@GN@(ZI,"CQM",""))
	. S KBAIFDA($$C0QGRFN(),ZIEN_",",5.1)=$O(@GN@(ZI,"CAT",""))
	. N OK
	. ;W ! ZWR KBAIFDA
	. ;ZWR @GN@(ZI,*)
	. N TRUST S TRUST=1 ; SKIP CHECKING IN UPDIE BECAUSE OF A FILEMAN BUG
	. D UPDIE(.KBAIFDA,.OK)
	Q
	;
RELOAD	; DELETES THE 176.801 AND 176.802 FILES AND RELOADS FROM XML, THEN
	; RESTORES THE MAPPINGS
	D BKMAPS ; MAKE SURE THE MAPPINGS ARE BACKED UP
	K ^TMP("KBAIVS","SID") ; START WITH NO SHORT IDS DEFINED
	K ^C0QVS(176.801)
	K ^C0QVS(176.802)
	W !,"REBUILDING MEASURE GROUPS"
	D ADDGRPS ; IMPORT GROUP DEFINITIONS
	W !,"REBUILDING VALUE SETS"
	D IMPORT ; IMPORT VALUESET DEFINITIONS
	;D ADDGRPS ; repeat group add now that we have done one pass
	D IMPORT ; repeat import now that we have all the groups
	D IMPSID ; IMPORT SHORT IDENTIFIERS
	D RESTORE
	D VALIDATE
	Q
	;
